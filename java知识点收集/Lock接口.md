# Lock接口

## 1、Lock接口定义及API

**Lock是是一个接口，它定义了锁获取和释放的基本操作，Lock的基本API如下：**

| 方法名称                                  | 描述                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| void lock()                               | 调用该方法的线程会去获得锁，当锁获取成功后才会返回           |
| void lockInterruptibly()                  | 可以中断地获取锁，与lock方法不同的地方在于该方法会响应中断，即在锁的获取过程中可以中断当前线程 |
| boolean tryLock()                         | 尝试非阻塞的获取锁，调用该方法后会立刻返回，如果能够获取到锁则返回true，否则返回false |
| boolean tryLock(long time, TimeUnit unit) | 等待超时的方式获取锁，当前线程调用该方法后在以下三种情况下会返回：<br />1、当前线程在超时时间内获取到了锁<br />2、当前线程在超时时间内被中断<br />3、超时时间结束后，返回false |
| void unlock()                             | 释放锁                                                       |
| Condition newCondition()                  | 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait方法，而调用后，而调用后，当前线程进入阻塞等待状态，并将锁释放 |

## 2、Lock的基本使用方式

```java
private Lock lock = new ReentrantLock();
public void testLock(){
    lock.lock();	//	获取锁
    try{
        //	业务代码
    }catch(Exception e){
        e.printStackTrace();
    }finally{
        lock.unlock();	//	释放锁
    }
}
```

## 3、Lock与synchronized关键字比较

**Lock接口提供了synchronized关键字所不具备的特性如下表**

| 特性               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| 尝试非阻塞地获取锁 | 当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 |
| 能够中断地获取锁   | 与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 |
| 超时获取锁         | 在指定地截止事件之前获取锁，如果截止时间到了仍旧无法获取锁，则返回 |

